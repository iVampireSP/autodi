package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"
	"sort"
	"strings"
	"unicode"
)

const generatedHeader = "// Code generated by autodi, DO NOT EDIT.\n\n"

// GeneratedFile represents a file to be written.
type GeneratedFile struct {
	Name    string
	Content []byte
}

// CloseableField records a field with a cleanup method.
type CloseableField struct {
	VarName string
	Method  string // "Close", "Shutdown", "Stop"
	HasCtx  bool   // method takes context.Context as first param
}

// CodeGen orchestrates code generation.
type CodeGen struct {
	cfg        *Config
	graph      *Graph
	commands   []*DiscoveredCommand
	moduleRoot string
	imports    *ImportManager
}

// ImportManager tracks imports and handles alias conflicts.
type ImportManager struct {
	imports map[string]string // pkgPath → alias (or empty for default)
	used    map[string]string // pkgName → pkgPath (first use wins)
}

func NewImportManager() *ImportManager {
	return &ImportManager{
		imports: make(map[string]string),
		used:    make(map[string]string),
	}
}

// Add registers an import and returns the qualifier to use in code.
func (im *ImportManager) Add(pkgPath, pkgName string) string {
	if pkgPath == "" {
		return ""
	}

	// Already registered
	if alias, ok := im.imports[pkgPath]; ok {
		if alias != "" {
			return alias
		}
		return pkgName
	}

	// Check for name conflict
	if existingPath, conflict := im.used[pkgName]; conflict && existingPath != pkgPath {
		// Need an alias
		alias := im.makeAlias(pkgPath, pkgName)
		im.imports[pkgPath] = alias
		im.used[alias] = pkgPath
		return alias
	}

	im.imports[pkgPath] = "" // no alias needed
	im.used[pkgName] = pkgPath
	return pkgName
}

// AddWithAlias registers an import with an explicit alias.
func (im *ImportManager) AddWithAlias(pkgPath, alias string) string {
	if pkgPath == "" {
		return ""
	}
	if existing, ok := im.imports[pkgPath]; ok {
		if existing != "" {
			return existing
		}
		// Already registered without alias — keep it
		return pkgShortName(pkgPath)
	}
	im.imports[pkgPath] = alias
	im.used[alias] = pkgPath
	return alias
}

func (im *ImportManager) makeAlias(pkgPath, pkgName string) string {
	parts := strings.Split(pkgPath, "/")
	if len(parts) >= 2 {
		parent := parts[len(parts)-2]
		alias := parent + pkgName
		if _, exists := im.used[alias]; !exists {
			return alias
		}
	}
	// Fallback
	for i := 2; ; i++ {
		alias := fmt.Sprintf("%s%d", pkgName, i)
		if _, exists := im.used[alias]; !exists {
			return alias
		}
	}
}

// FormatBlock returns the import block as Go source.
func (im *ImportManager) FormatBlock() string {
	if len(im.imports) == 0 {
		return ""
	}

	var paths []string
	for p := range im.imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	var buf bytes.Buffer
	buf.WriteString("import (\n")
	for _, p := range paths {
		alias := im.imports[p]
		if alias != "" {
			fmt.Fprintf(&buf, "\t%s %q\n", alias, p)
		} else {
			fmt.Fprintf(&buf, "\t%q\n", p)
		}
	}
	buf.WriteString(")\n")
	return buf.String()
}

// IsQualifier checks if a name is used as an import qualifier.
func (im *ImportManager) IsQualifier(name string) bool {
	_, ok := im.used[name]
	return ok
}

// Reset clears all imports for a new file.
func (im *ImportManager) Reset() {
	im.imports = make(map[string]string)
	im.used = make(map[string]string)
}

// NewCodeGen creates a code generator.
func NewCodeGen(cfg *Config, graph *Graph, commands []*DiscoveredCommand, moduleRoot string) *CodeGen {
	return &CodeGen{
		cfg:        cfg,
		graph:      graph,
		commands:   commands,
		moduleRoot: moduleRoot,
		imports:    NewImportManager(),
	}
}

// Generate produces the main.go file.
func (cg *CodeGen) Generate() ([]GeneratedFile, error) {
	f, err := cg.generateMain()
	if err != nil {
		return nil, err
	}
	return []GeneratedFile{f}, nil
}

// generateMain generates the complete main.go with two-phase DI.
func (cg *CodeGen) generateMain() (GeneratedFile, error) {
	cg.imports.Reset()

	// Pre-register cmd package imports with predictable aliases
	cmdAliases := make(map[string]string) // pkgPath → alias
	for _, cmd := range cg.commands {
		alias := cmd.PkgName + "cmd"
		cmdAliases[cmd.PkgPath] = cg.imports.AddWithAlias(cmd.PkgPath, alias)
	}

	// We'll build the main function body and init functions separately,
	// then combine them. First, generate all init functions to discover imports.
	var initBuf bytes.Buffer
	for _, cmd := range cg.commands {
		if !cmd.HasDeps() {
			continue
		}
		if err := cg.generateInitFunc(&initBuf, cmd, cmdAliases[cmd.PkgPath]); err != nil {
			return GeneratedFile{}, fmt.Errorf("generate init for %s: %w", cmd.Name, err)
		}
		initBuf.WriteString("\n")
	}

	// Now generate the main function
	var mainBuf bytes.Buffer

	// Embed directives
	for _, embed := range cg.cfg.Embeds {
		fmt.Fprintf(&mainBuf, "//go:embed %s\n", embed.Pattern)
		fmt.Fprintf(&mainBuf, "var %sFS embed.FS\n\n", embed.Dir)
		cg.imports.Add("embed", "embed")
	}

	// main function
	cg.imports.Add("os", "os")
	cobraQualifier := cg.imports.Add("github.com/spf13/cobra", "cobra")

	// Config init
	configQualifier := cg.imports.Add(cg.cfg.Module+"/internal/infra/config", "config")

	mainBuf.WriteString("func main() {\n")

	// Initialize config
	if len(cg.cfg.Embeds) > 0 {
		embed := cg.cfg.Embeds[0]
		fmt.Fprintf(&mainBuf, "\t%s.MustInitWithFS(%sFS, %q)\n\n", configQualifier, embed.Dir, embed.Dir)
	}

	// Root command
	fmt.Fprintf(&mainBuf, "\troot := &%s.Command{Use: %q, Short: %q", cobraQualifier, cg.cfg.AppName, cg.cfg.AppShort)
	if cg.cfg.AppLong != "" {
		fmt.Fprintf(&mainBuf, ", Long: %q", cg.cfg.AppLong)
	}
	mainBuf.WriteString("}\n\n")

	// Init function map (for DI commands)
	hasDI := false
	for _, cmd := range cg.commands {
		if cmd.HasDeps() {
			hasDI = true
			break
		}
	}

	if hasDI {
		fmt.Fprintf(&mainBuf, "\ttype initFunc func(cmd, top *%s.Command) (func(), error)\n", cobraQualifier)
		fmt.Fprintf(&mainBuf, "\tinitFuncs := make(map[*%s.Command]initFunc)\n\n", cobraQualifier)
	}

	// Register all commands
	for _, cmd := range cg.commands {
		alias := cmdAliases[cmd.PkgPath]
		exportName := cmdExportName(cmd.Name)

		// Generate zero-value args for constructor
		var zeroArgs []string
		for _, param := range cmd.Params {
			zeroArgs = append(zeroArgs, zeroValueForType(param.Type))
		}

		mainBuf.WriteString("\t{\n")
		fmt.Fprintf(&mainBuf, "\t\tstub := %s.%s(%s)\n", alias, cmd.FuncName, strings.Join(zeroArgs, ", "))

		if cmd.IsSingle {
			// Single command: Command() + direct RunE → Handle
			mainBuf.WriteString("\t\tcmd := stub.Command()\n")
			fmt.Fprintf(&mainBuf, "\t\tcmd.RunE = func(c *%s.Command, _ []string) error { return stub.Handle(c) }\n", cobraQualifier)
			mainBuf.WriteString("\t\troot.AddCommand(cmd)\n")
			if cmd.HasDeps() {
				fmt.Fprintf(&mainBuf, "\t\tinitFuncs[cmd] = init%s\n", exportName)
			}
		} else {
			// Multi-subcommand: Command() + wireRunE for each handler
			mainBuf.WriteString("\t\ttree := stub.Command()\n")
			for _, h := range cmd.Handlers {
				cmdName := pascalToKebab(h.MethodName)
				fmt.Fprintf(&mainBuf, "\t\twireRunE(tree, %q, stub.%s)\n", cmdName, h.MethodName)
			}
			mainBuf.WriteString("\t\troot.AddCommand(tree)\n")
			if cmd.HasDeps() {
				fmt.Fprintf(&mainBuf, "\t\tinitFuncs[tree] = init%s\n", exportName)
			}
		}

		mainBuf.WriteString("\t}\n")
	}

	// PersistentPreRunE / PostRunE
	if hasDI {
		mainBuf.WriteString("\n\tvar cleanup func()\n")
		fmt.Fprintf(&mainBuf, "\troot.PersistentPreRunE = func(cmd *%s.Command, args []string) error {\n", cobraQualifier)
		mainBuf.WriteString("\t\ttop := cmd\n")
		mainBuf.WriteString("\t\tfor top.HasParent() && top.Parent().HasParent() {\n")
		mainBuf.WriteString("\t\t\ttop = top.Parent()\n")
		mainBuf.WriteString("\t\t}\n")
		mainBuf.WriteString("\t\tif fn, ok := initFuncs[top]; ok {\n")
		mainBuf.WriteString("\t\t\tvar err error\n")
		mainBuf.WriteString("\t\t\tcleanup, err = fn(cmd, top)\n")
		mainBuf.WriteString("\t\t\treturn err\n")
		mainBuf.WriteString("\t\t}\n")
		mainBuf.WriteString("\t\treturn nil\n")
		mainBuf.WriteString("\t}\n")
		fmt.Fprintf(&mainBuf, "\troot.PersistentPostRunE = func(cmd *%s.Command, args []string) error {\n", cobraQualifier)
		mainBuf.WriteString("\t\tif cleanup != nil {\n")
		mainBuf.WriteString("\t\t\tcleanup()\n")
		mainBuf.WriteString("\t\t}\n")
		mainBuf.WriteString("\t\treturn nil\n")
		mainBuf.WriteString("\t}\n")
	}

	mainBuf.WriteString("\n\tif err := root.Execute(); err != nil {\n")
	fmt.Fprintf(&mainBuf, "\t\tos.Exit(1)\n")
	mainBuf.WriteString("\t}\n")
	mainBuf.WriteString("}\n")

	// Generate helper functions
	var helperBuf bytes.Buffer

	// wireRunE — always needed (all commands use it for handler wiring)
	cg.imports.Add("strings", "strings")
	helperBuf.WriteString("// wireRunE connects a handler method to a subcommand's RunE by kebab-case name.\n")
	helperBuf.WriteString("// For nested commands, the name segments form a path (e.g. \"pool-list\" matches pool→list).\n")
	fmt.Fprintf(&helperBuf, "func wireRunE(parent *%s.Command, name string, handler func(*%s.Command) error) {\n", cobraQualifier, cobraQualifier)
	helperBuf.WriteString("\t// Try exact match first (direct child)\n")
	helperBuf.WriteString("\tfor _, sub := range parent.Commands() {\n")
	helperBuf.WriteString("\t\tif sub.Name() == name {\n")
	helperBuf.WriteString("\t\t\th := handler\n")
	fmt.Fprintf(&helperBuf, "\t\t\tsub.RunE = func(cmd *%s.Command, _ []string) error { return h(cmd) }\n", cobraQualifier)
	helperBuf.WriteString("\t\t\treturn\n")
	helperBuf.WriteString("\t\t}\n")
	helperBuf.WriteString("\t}\n")
	helperBuf.WriteString("\t// Try path-based match: split name by \"-\" and greedily match child commands\n")
	helperBuf.WriteString("\tparts := strings.Split(name, \"-\")\n")
	helperBuf.WriteString("\twireRunEPath(parent, parts, handler)\n")
	helperBuf.WriteString("}\n\n")

	fmt.Fprintf(&helperBuf, "func wireRunEPath(parent *%s.Command, parts []string, handler func(*%s.Command) error) bool {\n", cobraQualifier, cobraQualifier)
	helperBuf.WriteString("\tif len(parts) == 0 {\n")
	helperBuf.WriteString("\t\treturn false\n")
	helperBuf.WriteString("\t}\n")
	helperBuf.WriteString("\t// Try progressively longer prefixes as the child command name\n")
	helperBuf.WriteString("\tfor i := 1; i <= len(parts); i++ {\n")
	helperBuf.WriteString("\t\tcandidate := strings.Join(parts[:i], \"-\")\n")
	helperBuf.WriteString("\t\tfor _, sub := range parent.Commands() {\n")
	helperBuf.WriteString("\t\t\tif sub.Name() != candidate {\n")
	helperBuf.WriteString("\t\t\t\tcontinue\n")
	helperBuf.WriteString("\t\t\t}\n")
	helperBuf.WriteString("\t\t\tif i == len(parts) {\n")
	helperBuf.WriteString("\t\t\t\t// Leaf match\n")
	helperBuf.WriteString("\t\t\t\th := handler\n")
	fmt.Fprintf(&helperBuf, "\t\t\t\tsub.RunE = func(cmd *%s.Command, _ []string) error { return h(cmd) }\n", cobraQualifier)
	helperBuf.WriteString("\t\t\t\treturn true\n")
	helperBuf.WriteString("\t\t\t}\n")
	helperBuf.WriteString("\t\t\t// Try remaining parts as deeper path\n")
	helperBuf.WriteString("\t\t\tif wireRunEPath(sub, parts[i:], handler) {\n")
	helperBuf.WriteString("\t\t\t\treturn true\n")
	helperBuf.WriteString("\t\t\t}\n")
	helperBuf.WriteString("\t\t}\n")
	helperBuf.WriteString("\t}\n")
	helperBuf.WriteString("\treturn false\n")
	helperBuf.WriteString("}\n")

	// swapRunE + relativePath — only needed for DI commands
	if hasDI {
		helperBuf.WriteString("\n// swapRunE replaces the executing command's RunE with the real one from the DI-built tree.\n")
		fmt.Fprintf(&helperBuf, "func swapRunE(executing, stubTop, realTop *%s.Command) {\n", cobraQualifier)
		helperBuf.WriteString("\tpath := relativePath(executing, stubTop)\n")
		helperBuf.WriteString("\ttarget := realTop\n")
		helperBuf.WriteString("\tfor _, name := range path {\n")
		helperBuf.WriteString("\t\tfor _, sub := range target.Commands() {\n")
		helperBuf.WriteString("\t\t\tif sub.Name() == name {\n")
		helperBuf.WriteString("\t\t\t\ttarget = sub\n")
		helperBuf.WriteString("\t\t\t\tbreak\n")
		helperBuf.WriteString("\t\t\t}\n")
		helperBuf.WriteString("\t\t}\n")
		helperBuf.WriteString("\t}\n")
		helperBuf.WriteString("\texecuting.RunE = target.RunE\n")
		helperBuf.WriteString("}\n\n")
		fmt.Fprintf(&helperBuf, "func relativePath(cmd, ancestor *%s.Command) []string {\n", cobraQualifier)
		helperBuf.WriteString("\tif cmd == ancestor {\n")
		helperBuf.WriteString("\t\treturn nil\n")
		helperBuf.WriteString("\t}\n")
		helperBuf.WriteString("\treturn append(relativePath(cmd.Parent(), ancestor), cmd.Name())\n")
		helperBuf.WriteString("}\n")
	}

	// Combine everything
	var full bytes.Buffer
	full.WriteString(generatedHeader)
	full.WriteString("package main\n\n")
	full.WriteString(cg.imports.FormatBlock())
	full.WriteString("\n")
	full.Write(mainBuf.Bytes())
	full.WriteString("\n")
	full.Write(initBuf.Bytes())
	if helperBuf.Len() > 0 {
		full.WriteString("\n")
		full.Write(helperBuf.Bytes())
	}

	src, err := format.Source(full.Bytes())
	if err != nil {
		return GeneratedFile{Name: "main.go", Content: full.Bytes()},
			fmt.Errorf("format main.go: %w\n--- source ---\n%s", err, full.String())
	}

	return GeneratedFile{Name: "main.go", Content: src}, nil
}

// generateInitFunc generates an init<Cmd> function for a DI command.
func (cg *CodeGen) generateInitFunc(buf *bytes.Buffer, cmd *DiscoveredCommand, cmdAlias string) error {
	exportName := cmdExportName(cmd.Name)
	cobraQualifier := cg.imports.Add("github.com/spf13/cobra", "cobra")

	// Determine which types this command needs (from NewCommand params)
	var neededTypes []string
	var groupParams []struct {
		idx       int
		groupName string
	}

	for i, param := range cmd.Params {
		groupName := cg.matchGroup(param.TypeStr)
		if groupName != "" {
			groupParams = append(groupParams, struct {
				idx       int
				groupName string
			}{i, groupName})
			// Include all group providers' dependencies
			for _, p := range cg.graph.Groups[groupName] {
				for _, dep := range p.Params {
					neededTypes = append(neededTypes, dep.TypeStr)
				}
			}
		} else {
			neededTypes = append(neededTypes, param.TypeStr)
		}
	}

	// Get providers in topological order
	providers, err := cg.graph.ProvidersForTypes(neededTypes)
	if err != nil {
		return fmt.Errorf("resolve deps for %s: %w", cmd.Name, err)
	}

	// Build type → local var name mapping
	varMap := make(map[string]string) // typeStr → local var name
	usedVars := make(map[string]bool)

	// Build set of "consumed" types — types actually referenced as params
	consumedTypes := make(map[string]bool)
	for _, p := range providers {
		for _, param := range p.Params {
			consumedTypes[param.TypeStr] = true
			consumedTypes[cg.graph.resolveType(param.TypeStr)] = true
		}
	}
	// Command params are also consumed
	for _, param := range cmd.Params {
		consumedTypes[param.TypeStr] = true
		consumedTypes[cg.graph.resolveType(param.TypeStr)] = true
	}
	// Group provider params are consumed
	for _, gp := range groupParams {
		for _, p := range cg.graph.Groups[gp.groupName] {
			for _, dep := range p.Params {
				consumedTypes[dep.TypeStr] = true
				consumedTypes[cg.graph.resolveType(dep.TypeStr)] = true
			}
		}
	}
	// Interface bindings: if an interface is consumed, its concrete type is too
	for ifaceStr, concreteStr := range cg.graph.Bindings {
		if consumedTypes[ifaceStr] {
			consumedTypes[concreteStr] = true
		}
	}

	// Generate function signature
	fmt.Fprintf(buf, "func init%s(cmd, top *%s.Command) (func(), error) {\n", exportName, cobraQualifier)

	hasAnyError := false
	for _, p := range providers {
		if p.HasError {
			hasAnyError = true
			break
		}
	}
	if hasAnyError {
		cg.imports.Add("fmt", "fmt")
	}

	// Generate provider calls in topological order
	var closeables []CloseableField
	for _, p := range providers {
		cg.writeLocalProviderCall(buf, p, varMap, usedVars, &closeables, consumedTypes)
		buf.WriteString("\n")
	}

	// Write interface bindings
	for ifaceStr, concreteStr := range cg.graph.Bindings {
		if concreteVar, ok := varMap[concreteStr]; ok {
			if _, needed := varMap[ifaceStr]; !needed {
				// Check if this interface type is needed by any group provider or command param
				if cg.isTypeNeeded(ifaceStr, neededTypes, cmd) {
					varMap[ifaceStr] = concreteVar
				}
			}
		}
	}

	// Build group slices
	for _, gp := range groupParams {
		groupName := gp.groupName
		groupProviders := cg.graph.Groups[groupName]
		if len(groupProviders) == 0 {
			continue
		}

		groupCfg := cg.cfg.Groups[groupName]
		groupVarName := localVarName(GroupFieldName(groupName))
		if usedVars[groupVarName] {
			groupVarName = groupVarName + "Group"
		}
		usedVars[groupVarName] = true

		ifaceType := cg.qualifyType(groupCfg.Interface, "")
		fmt.Fprintf(buf, "\t%s := []%s{\n", groupVarName, ifaceType)
		for _, p := range groupProviders {
			qualifier := cg.qualifyFunc(p)
			args := cg.buildLocalArgs(p, varMap)
			fmt.Fprintf(buf, "\t\t%s(%s),\n", qualifier, strings.Join(args, ", "))
		}
		buf.WriteString("\t}\n\n")

		// Register the slice in varMap for the NewCommand call
		varMap[cmd.Params[gp.idx].TypeStr] = groupVarName
	}

	// Build NewCommand args
	var newCmdArgs []string
	for _, param := range cmd.Params {
		if varName, ok := varMap[param.TypeStr]; ok {
			newCmdArgs = append(newCmdArgs, varName)
		} else {
			// Try resolving via bindings
			resolved := cg.graph.resolveType(param.TypeStr)
			if varName, ok := varMap[resolved]; ok {
				newCmdArgs = append(newCmdArgs, varName)
			} else {
				newCmdArgs = append(newCmdArgs, "nil /* unresolved: "+toShortTypeName(param.TypeStr)+" */")
			}
		}
	}

	// Create real command instance and wire handlers
	fmt.Fprintf(buf, "\treal := %s.%s(%s)\n", cmdAlias, cmd.FuncName, strings.Join(newCmdArgs, ", "))

	if cmd.IsSingle {
		// Single command: Command() + direct RunE → Handle
		cobraQ := cg.imports.Add("github.com/spf13/cobra", "cobra")
		fmt.Fprintf(buf, "\trealCmd := real.Command()\n")
		fmt.Fprintf(buf, "\trealCmd.RunE = func(c *%s.Command, _ []string) error { return real.Handle(c) }\n", cobraQ)
		fmt.Fprintf(buf, "\tswapRunE(cmd, top, realCmd)\n\n")
	} else {
		// Multi-subcommand: Command() + wireRunE for each handler
		fmt.Fprintf(buf, "\ttree := real.Command()\n")
		for _, h := range cmd.Handlers {
			cmdName := pascalToKebab(h.MethodName)
			fmt.Fprintf(buf, "\twireRunE(tree, %q, real.%s)\n", cmdName, h.MethodName)
		}
		fmt.Fprintf(buf, "\tswapRunE(cmd, top, tree)\n\n")
	}

	// Generate cleanup function
	if len(closeables) > 0 {
		buf.WriteString("\treturn func() {\n")
		for i := len(closeables) - 1; i >= 0; i-- {
			cl := closeables[i]
			if cl.HasCtx {
				cg.imports.Add("context", "context")
				fmt.Fprintf(buf, "\t\tif %s != nil {\n\t\t\t%s.%s(context.Background())\n\t\t}\n", cl.VarName, cl.VarName, cl.Method)
			} else {
				fmt.Fprintf(buf, "\t\tif %s != nil {\n\t\t\t%s.%s()\n\t\t}\n", cl.VarName, cl.VarName, cl.Method)
			}
		}
		buf.WriteString("\t}, nil\n")
	} else {
		buf.WriteString("\treturn nil, nil\n")
	}
	buf.WriteString("}\n")

	return nil
}

// writeLocalProviderCall writes a provider call using local variables.
func (cg *CodeGen) writeLocalProviderCall(buf *bytes.Buffer, p *Provider, varMap map[string]string, usedVars map[string]bool, closeables *[]CloseableField, consumedTypes map[string]bool) {
	qualifier := cg.qualifyFunc(p)
	args := cg.buildLocalArgs(p, varMap)

	// Determine local var names for return types
	var lhsNames []string
	for _, ret := range p.Returns {
		// Check if this return type is actually consumed
		isConsumed := consumedTypes[ret.TypeStr]
		if !isConsumed {
			// Also check via bindings
			for ifaceStr := range consumedTypes {
				if cg.graph.resolveType(ifaceStr) == ret.TypeStr {
					isConsumed = true
					break
				}
			}
		}
		// Also check for closeable — we need the var name for cleanup
		hasClose := isNilable(ret.Type) && checkCloseable(ret.Type, "_") != nil

		if !isConsumed && !hasClose {
			lhsNames = append(lhsNames, "_")
			continue
		}

		fieldName := FieldName(ret.TypeStr)
		varName := localVarName(fieldName)
		// Avoid shadowing import qualifiers
		if cg.imports.IsQualifier(varName) {
			varName = varName + "Svc"
		}
		// Ensure uniqueness
		origVarName := varName
		for i := 2; usedVars[varName]; i++ {
			varName = fmt.Sprintf("%s%d", origVarName, i)
		}
		usedVars[varName] = true
		lhsNames = append(lhsNames, varName)
		varMap[ret.TypeStr] = varName

		// Check for closeable
		if isNilable(ret.Type) {
			if cl := checkCloseable(ret.Type, varName); cl != nil {
				*closeables = append(*closeables, CloseableField{
					VarName: varName,
					Method:  cl.Method,
					HasCtx:  cl.HasCtx,
				})
			}
		}
	}

	if p.HasError {
		if len(lhsNames) > 0 {
			fmt.Fprintf(buf, "\t%s, err := %s(%s)\n", strings.Join(lhsNames, ", "), qualifier, strings.Join(args, ", "))
		} else {
			fmt.Fprintf(buf, "\t_, err := %s(%s)\n", qualifier, strings.Join(args, ", "))
		}
		fmt.Fprintf(buf, "\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"%s.%s: %%w\", err)\n", p.PkgName, p.FuncName)
		fmt.Fprintf(buf, "\t}\n")
	} else {
		if len(lhsNames) > 0 {
			fmt.Fprintf(buf, "\t%s := %s(%s)\n", strings.Join(lhsNames, ", "), qualifier, strings.Join(args, ", "))
		} else {
			fmt.Fprintf(buf, "\t%s(%s)\n", qualifier, strings.Join(args, ", "))
		}
	}
}

// buildLocalArgs constructs the argument list for a provider call using local vars.
func (cg *CodeGen) buildLocalArgs(p *Provider, varMap map[string]string) []string {
	var args []string
	for _, param := range p.Params {
		resolved := cg.graph.resolveType(param.TypeStr)
		if varName, ok := varMap[resolved]; ok {
			args = append(args, varName)
		} else if varName, ok := varMap[param.TypeStr]; ok {
			args = append(args, varName)
		} else {
			args = append(args, "nil /* missing: "+toShortTypeName(param.TypeStr)+" */")
		}
	}
	return args
}

// matchGroup checks if a type string matches a group definition.
// Returns the group name, or "" if not a group.
func (cg *CodeGen) matchGroup(typeStr string) string {
	if !strings.HasPrefix(typeStr, "[]") {
		return ""
	}
	elemType := typeStr[2:]

	for groupName, groupCfg := range cg.cfg.Groups {
		groupIfaceFull := cg.graph.resolveConfigType(groupCfg.Interface)
		if elemType == groupIfaceFull {
			return groupName
		}
	}
	return ""
}

// isTypeNeeded checks if a type is needed by the command or its group providers.
func (cg *CodeGen) isTypeNeeded(typeStr string, neededTypes []string, cmd *DiscoveredCommand) bool {
	for _, t := range neededTypes {
		if t == typeStr {
			return true
		}
	}
	// Check group provider params
	for _, param := range cmd.Params {
		groupName := cg.matchGroup(param.TypeStr)
		if groupName == "" {
			continue
		}
		for _, p := range cg.graph.Groups[groupName] {
			for _, dep := range p.Params {
				if dep.TypeStr == typeStr {
					return true
				}
			}
		}
	}
	return false
}

// qualifyFunc returns the qualified function call like "iam.NewIAM".
func (cg *CodeGen) qualifyFunc(p *Provider) string {
	alias := cg.imports.Add(p.PkgPath, p.PkgName)
	if alias == "" {
		return p.FuncName
	}
	return alias + "." + p.FuncName
}

// qualifyType converts a type string (possibly short config name) into Go source.
func (cg *CodeGen) qualifyType(typeStr, _ string) string {
	resolved := cg.graph.resolveConfigType(typeStr)
	return cg.shortType(resolved)
}

// shortType converts a fully qualified type string to its short form,
// registering imports as needed.
func (cg *CodeGen) shortType(typeStr string) string {
	prefix := ""
	s := typeStr

	if strings.HasPrefix(s, "*") {
		prefix = "*"
		s = s[1:]
	}

	dotIdx := strings.LastIndex(s, ".")
	if dotIdx < 0 {
		return typeStr
	}

	pkgPath := s[:dotIdx]
	typeName := s[dotIdx+1:]

	if !strings.Contains(pkgPath, "/") {
		resolved := cg.graph.resolveConfigType(typeStr)
		if resolved != typeStr {
			return cg.shortType(resolved)
		}
		if fullPkg, ok := cg.graph.pkgNameToPath[pkgPath]; ok {
			pkgPath = fullPkg
		}
	}

	pkgName := pkgShortName(pkgPath)
	qualifier := cg.imports.Add(pkgPath, pkgName)
	return prefix + qualifier + "." + typeName
}

// pkgShortName extracts the short package name from a full path.
func pkgShortName(pkgPath string) string {
	parts := strings.Split(pkgPath, "/")
	last := parts[len(parts)-1]

	if len(last) >= 2 && last[0] == 'v' && last[1] >= '0' && last[1] <= '9' {
		if len(parts) >= 2 {
			candidate := parts[len(parts)-2]
			if idx := strings.LastIndex(candidate, "-"); idx >= 0 {
				return candidate[idx+1:]
			}
			return candidate
		}
	}
	return last
}

// localVarName converts a FieldName to a local variable name.
func localVarName(fieldName string) string {
	if fieldName == "" {
		return ""
	}
	runes := []rune(fieldName)

	// Count leading uppercase characters
	upperCount := 0
	for upperCount < len(runes) && unicode.IsUpper(runes[upperCount]) {
		upperCount++
	}

	if upperCount == 0 {
		return fieldName
	}

	if upperCount == len(runes) {
		// All uppercase: JWT → jwt, MQ → mq, IAM → iam
		return strings.ToLower(fieldName)
	}

	if upperCount == 1 {
		// Single uppercase: EntClient → entClient
		return strings.ToLower(string(runes[0])) + string(runes[1:])
	}

	// Multiple uppercase prefix: IamAuthN → iamAuthN, HTTPServer → httpServer
	return strings.ToLower(string(runes[:upperCount-1])) + string(runes[upperCount-1:])
}

// zeroValueForType returns the zero value literal for a Go type.
func zeroValueForType(t types.Type) string {
	switch u := t.Underlying().(type) {
	case *types.Pointer, *types.Interface, *types.Map, *types.Slice, *types.Chan:
		return "nil"
	case *types.Basic:
		switch u.Kind() {
		case types.String:
			return `""`
		case types.Bool:
			return "false"
		default:
			return "0"
		}
	default:
		return "nil"
	}
}

// cmdExportName converts a command name to an exported function name.
// "admin_api" → "AdminAPI", "admin" → "Admin"
func cmdExportName(name string) string {
	parts := strings.Split(name, "_")
	var result string
	for _, p := range parts {
		if len(p) <= 3 {
			result += strings.ToUpper(p)
		} else {
			result += strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return result
}

// checkCloseable checks if a type has Close, Shutdown, or Stop methods.
func checkCloseable(t types.Type, varName string) *CloseableField {
	mset := types.NewMethodSet(t)

	for _, methodName := range []string{"Close", "Shutdown", "Stop"} {
		for i := 0; i < mset.Len(); i++ {
			method := mset.At(i)
			if method.Obj().Name() != methodName {
				continue
			}
			sig, ok := method.Type().(*types.Signature)
			if !ok {
				continue
			}

			params := sig.Params()
			hasCtx := false

			switch params.Len() {
			case 0:
				// No params — valid cleanup method
			case 1:
				if isContextType(params.At(0).Type()) {
					hasCtx = true
				} else {
					continue
				}
			default:
				continue
			}

			return &CloseableField{
				VarName: varName,
				Method:  methodName,
				HasCtx:  hasCtx,
			}
		}
	}
	return nil
}

// isContextType checks if a type is context.Context.
func isContextType(t types.Type) bool {
	named, ok := t.(*types.Named)
	if !ok {
		return false
	}
	obj := named.Obj()
	return obj.Pkg() != nil && obj.Pkg().Path() == "context" && obj.Name() == "Context"
}

// isNilable checks if a type can be compared to nil.
func isNilable(t types.Type) bool {
	switch t.Underlying().(type) {
	case *types.Pointer, *types.Interface, *types.Map, *types.Slice, *types.Chan:
		return true
	}
	return false
}

// sortedGroupNames returns group names in deterministic order.
func sortedGroupNames(groups map[string]GroupConfig) []string {
	var names []string
	for name := range groups {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

// typePkgPathFromTypeStr extracts the package path from a full type string.
func typePkgPathFromTypeStr(typeStr string) string {
	s := strings.TrimPrefix(typeStr, "*")
	if idx := strings.LastIndex(s, "."); idx >= 0 {
		return s[:idx]
	}
	return ""
}
